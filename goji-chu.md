    {

    整型
    {
    int8、int16、int32和int64  -128~127 。。。
    uint8、uint16、uint32和uint64 0~255 。。。
    分别对应8、16、32、64bit大小的有无符号整形数
    对应特定CPU平台机器字大小的有符号和无符号整数int和uint  32/64
    Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。
    同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
    无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。（底层编程才用）
    int、uint和uintptr是不同类型的兄弟类型

    二元运算符有五种优先级。在同一个优先级，使用左优先结合规则：
    * / % << >> & &^(位清空 (AND NOT))
    + - | ^
    == != < <= > >=
    &&
    ||

    //%仅用于整数
    //对于整数，+x是0+x的简写，-x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x 的负数
    //无符号数往往只有在位运算或其它特殊的运算场景才会使用
    //任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。%d、%o或%x参数控制输出的进制格式
    //字符使用 %c 参数打印，或者是用 %q 参数打印带单引号的字符
    //常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的 [1] 副词告诉Printf函数再次使用第一个操作数。第二，%后的 # 副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
    fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
    }

    浮点型
    {
    float32和float64
    %g参数打印浮点数
    表格的数据，使用%e（带指数） 或%f的形式打印可能更合适	
    fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
    NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)
    math.IsNaN用于测试一个数是否是非数NaN
    }

    复数
    {
    complex64和complex128，分别对应float32和float64两种浮点数精度	
    }

    布尔型
    {
    	一个布尔类型的值只有两种：true和false。
    }

    字符串
    {
    一个字符串是一个不可改变的字节序列。字符串的值是不可变的
    文本字符串通常被解释为采用UTF8编码的Unicode码点（rune） 序列	
    内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目） ，
    索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。
    超出字符串索引范围的字节将会导致panic异常
    第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。
    子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身） 
    字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序

    Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，
    因此我们可以将Unicode码点也写到字符串面值中

    原生的字符串用`

    现在utf8已经是Unicode的标准，UTF8编码使用1到4个字节来表示每个Unicode码点

    标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包

    strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
    bytes包提供了针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效。
    strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
    unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每
    个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的
    转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。


    }

    常量	
    {
    常量表达式的值在编译期计算，而不是在运行期。
    const (
    e = 2.71828182845904523536028747135266249775724709369995957496696763
    pi = 3.14159265358979323846264338327950288419716939937510582097494459
    )

    iota 常量生成器
    const (
    	Sunday Weekday = iota
    	Monday
    	Tuesday
    	Wednesday
    	Thursday
    	Friday
    	Saturday
    )




    }

    }




